#!/bin/zsh

# git-upload
#
# Usage:
#   git-upload [-ai|--aiDiffCommitMsg [ai-context]] [commit message]
#
# Behaviour:
#   - If --aiDiffCommitMsg / -ai is passed, the script will generate a commit
#     message from the current diff using GitHub Copilot CLI by default.
#   - The first non-flag argument after -ai (if any) is treated as optional
#     extra context to append to the default AI prompt.
#   - The next non-flag argument (if any) is used as a fallback/manual
#     commit message if AI is unavailable or fails.
#   - Without -ai, the first non-flag argument is the commit message,
#     defaulting to "default commit message".
#
# AI integration:
#   Default behaviour (no configuration needed as long as `copilot` is
#   installed and on PATH):
#     - The script builds a prompt like:
#         "examine differences between the last known push to this repository
#          and the current state, write a clean concise one-three line message
#          for this diff"
#       and, if you provided [ai-context] after -ai, appends that text.
#     - It then calls GitHub Copilot CLI non-interactively:
#         copilot -s --allow-all-tools --allow-all-paths -p "$GIT_UPLOAD_AI_PROMPT"
#
#   Advanced: you may optionally override the full AI command via
#   GIT_UPLOAD_AI_CMD for a single shell/session, but this is not required.

set -euo pipefail

use_ai=false
user_msg=""
ai_extra_context=""

DEFAULT_AI_CMD='copilot -s --allow-all-tools --allow-all-paths -p "$GIT_UPLOAD_AI_PROMPT"'

expect_ai_context_next=false

for arg in "$@"; do
	case "$arg" in
		--aiDiffCommitMsg|-ai)
			use_ai=true
			expect_ai_context_next=true
			;;
		--*)
			# Ignore other flags for now
			;;
		*)
			if [ "$expect_ai_context_next" = true ]; then
				# This non-flag arg immediately after -ai/--aiDiffCommitMsg
				# is treated as optional extra AI context.
				ai_extra_context="$arg"
				expect_ai_context_next=false
			elif [ -z "$user_msg" ]; then
				user_msg="$arg"
			fi
			;;
	esac
done

generate_ai_message() {
	local ai_cmd

	if [ -n "${GIT_UPLOAD_AI_CMD-}" ]; then
		ai_cmd="$GIT_UPLOAD_AI_CMD"
	else
		ai_cmd="$DEFAULT_AI_CMD"
	fi

	local ai_binary
	ai_binary=${ai_cmd%% *}
	if ! command -v "$ai_binary" >/dev/null 2>&1; then
		echo "[git-upload] AI command '$ai_binary' not found. " \
			"Install GitHub Copilot CLI (e.g. 'brew install copilot-cli' on macOS) " \
			"and ensure it is on your PATH." >&2
		return 1
	fi

	local default_prompt="You are generating a git commit message for the CURRENT STAGED CHANGES.

Your job:
- Determine what changed between the last commit (HEAD) and the current staged snapshot (index). If there is no HEAD yet (initial commit), base it on the staged snapshot.
- Write a reasonable-length but very informative commit message that explains what changed and why, so a teammate can understand it weeks later.

Content requirements:
- Base everything on the staged diff (index) vs HEAD; do not invent changes.
- If multiple areas changed, group them; prioritize user-visible behavior changes and operational impact.
- Call out CLI/API behavior changes, default behavior changes, and backwards compatibility.
- If applicable, include migration steps; otherwise explicitly say: Breaking changes: none
- Include a short risk assessment; if nothing stands out, say: Risk: low
- Include Testing; if you cannot confirm tests were run, say: Testing: not provided

Style requirements:
- Subject line: imperative mood; concise and specific; aim for <= 72 characters when feasible.
- Body: detailed but not padded; prefer bullets.
- Do NOT mention checking status, diffs, tools, agents, prompts, or instructions.

Output protocol (IMPORTANT):
- Output ONLY the commit message between these exact markers, with no other text:
COMMIT_BEGIN
<subject line>

<body, multiple lines allowed>
COMMIT_END

Suggested body structure (adapt as needed):
Summary:
- <bullet per major change>
Why:
- <motivation/problem addressed>
Breaking changes: <none|describe>
Risk: <low|medium|high> (<short rationale>)
Testing: <not provided|describe>
"
	local effective_prompt

	effective_prompt="$default_prompt"
	if [ -n "$ai_extra_context" ]; then
		effective_prompt="$effective_prompt

Additional context from user: $ai_extra_context"
	fi

	echo "[git-upload] Generating AI commit message via Copilot…" >&2

	# Call Copilot CLI (or overridden AI command) with the constructed prompt.
	# Capture full output so we can extract the commit message.
	local ai_output
	if ! ai_output=$(GIT_UPLOAD_AI_PROMPT="$effective_prompt" eval "$ai_cmd" 2>/dev/null); then
		echo "[git-upload] AI command '$ai_cmd' failed. " \
			"Make sure GitHub Copilot CLI is installed and you have run 'copilot' " \
			"at least once to authenticate." >&2
		return 1
	fi

	# Prefer COMMIT_BEGIN/COMMIT_END block; fall back to legacy single-line COMMIT:.
	local commit_block
	commit_block=$(printf '%s\n' "$ai_output" | awk '
		$0 == "COMMIT_BEGIN" { inside=1; next }
		$0 == "COMMIT_END" { inside=0 }
		inside { print }
	')

	if [ -n "${commit_block// /}" ]; then
		# Trim trailing blank lines.
		commit_block=$(printf '%s\n' "$commit_block" | awk '{ lines[NR]=$0 } $0 !~ /^[[:space:]]*$/ { last=NR } END { for (i=1; i<=last; i++) print lines[i] }')
		# Trim leading blank lines.
		commit_block=$(printf '%s\n' "$commit_block" | awk 'BEGIN{found=0} { if (!found && $0 ~ /^[[:space:]]*$/) next; found=1; print }')
		if [ -n "${commit_block// /}" ]; then
			printf '%s' "$commit_block"
			return 0
		fi
	fi

	local commit_line
	commit_line=$(printf '%s\n' "$ai_output" | grep '^COMMIT: ' | tail -n 1 | sed 's/^COMMIT: //')

	if [ -z "${commit_line// /}" ]; then
		echo "[git-upload] AI did not produce a COMMIT_BEGIN/COMMIT_END block (or legacy COMMIT: line); skipping AI" >&2
		return 1
	fi

	printf '%s' "$commit_line"
}

main() {
	# Determine current branch and ensure we're not in detached HEAD.
	# NOTE: `git rev-parse --abbrev-ref HEAD` can yield surprising output in
	# brand-new repos (unborn branch / no commits yet). `git symbolic-ref` is
	# the reliable way to identify the branch HEAD points to.
	current_branch=$(git symbolic-ref -q --short HEAD 2>/dev/null || echo "")
	if [ -z "$current_branch" ]; then
		# HEAD is detached (or otherwise not a symbolic ref).
		head_commit=$(git rev-parse -q --verify HEAD 2>/dev/null || echo "")
		if [ -z "$head_commit" ]; then
			echo "[git-upload] HEAD is not on a branch (and there are no commits yet)." >&2
			echo "[git-upload] Fix: create/switch to a branch first (for example: 'git switch -c main')." >&2
			exit 1
		fi

		# If the detached commit is already contained by exactly one local branch,
		# we can safely switch to it without losing work.
		containing_branches=$(git branch --contains "$head_commit" --format='%(refname:short)' 2>/dev/null || echo "")
		containing_count=$(printf '%s\n' "$containing_branches" | sed '/^$/d' | wc -l | tr -d ' ')

		if [ "$containing_count" = "1" ]; then
			current_branch=$(printf '%s\n' "$containing_branches" | sed -n '1p')
			echo "[git-upload] Detached HEAD is contained by '$current_branch'; switching to that branch…" >&2
			git switch "$current_branch" >/dev/null 2>&1 || {
				echo "[git-upload] Failed to switch to '$current_branch'." >&2
				exit 1
			}
		else
			echo "[git-upload] You are in a detached HEAD state. Checkout or create a branch before running git-upload." >&2
			echo "[git-upload] Fix (create a branch at the current commit): git switch -c <branch-name>" >&2
			exit 1
		fi
	fi

	# If this branch has an upstream, first make sure we're not behind it.
	# If we are, attempt a rebase so pushes will be fast-forward and won't
	# immediately fail due to "non-fast-forward" errors.
	if upstream_ref=$(git rev-parse --abbrev-ref --symbolic-full-name "@{u}" 2>/dev/null); then
		# Make sure we have the latest refs
		git fetch >/dev/null 2>&1 || true

		ahead_behind=$(git rev-list --left-right --count "$upstream_ref"...HEAD 2>/dev/null || echo "")
		behind_count=$(print -- "$ahead_behind" | awk '{print $1}')

		if [ -n "$behind_count" ] && [ "$behind_count" -gt 0 ]; then
			echo "[git-upload] Branch '$current_branch' is $behind_count commit(s) behind its upstream. Rebasing..." >&2
			if ! git pull --rebase --autostash >/dev/null 2>&1; then
				GIT_DIR=$(git rev-parse --git-dir 2>/dev/null || echo .git)
				if [ -d "$GIT_DIR/rebase-merge" ] || [ -d "$GIT_DIR/rebase-apply" ] || [ -f "$GIT_DIR/MERGE_HEAD" ]; then
					echo "[git-upload] git pull --rebase --autostash stopped due to conflicts." >&2
					echo "[git-upload] Run 'git resolve' for a safe backup and conflict-resolution guidance, resolve conflicts, then rerun git-upload." >&2
				else
					echo "[git-upload] git pull --rebase --autostash failed for this branch (for example, due to local changes or a hook/network error)." >&2
					echo "[git-upload] Run 'git resolve' for a safe backup and guidance on cleaning up your working tree, then rerun git-upload." >&2
				fi
				exit 1
			fi
		fi

		# After ensuring we're up to date, do a dry-run push to catch
		# permission/branch-protection issues before burning AI tokens.
		if ! git push --dry-run >/dev/null 2>&1; then
			echo "[git-upload] Unable to push to the upstream for '$current_branch'." >&2
			echo "[git-upload] This branch may be protected or you may not have permission to push directly." >&2
			echo "[git-upload] Push via a pull request or use a different branch before running git-upload." >&2
			exit 1
		fi
	fi

	git add .

	commit_msg="${user_msg:-default commit message}"

	if [ "$use_ai" = true ]; then
		if ai_msg=$(generate_ai_message); then
			# Prefer AI message; fall back to user_msg if AI returns empty
			if [ -n "${ai_msg// /}" ]; then
				commit_msg="$ai_msg"
			fi
		else
			# AI failed (e.g., Copilot not authenticated or not available)
			if [ -z "$user_msg" ]; then
				# No manual fallback message was provided; abort commit
				echo "[git-upload] AI commit requested but unavailable and no fallback commit message provided. Aborting commit." >&2
				exit 1
			fi
		fi
	fi

	echo "[git-upload] Using commit message: $commit_msg" >&2

	git commit -m "$commit_msg"

	# Push to the current branch's upstream if configured; otherwise
	# create/set upstream on origin for the current branch.
	if git rev-parse --abbrev-ref --symbolic-full-name "@{u}" >/dev/null 2>&1; then
		git push
	else
		git push -u origin "$current_branch"
	fi
}

main "$@"