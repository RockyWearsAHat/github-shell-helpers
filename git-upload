#!/bin/zsh

# git-upload
#
# Usage:
#   git-upload [-ai|--aiDiffCommitMsg [ai-context]] [commit message]
#
# Behaviour:
#   - If --aiDiffCommitMsg / -ai is passed, the script will generate a commit
#     message from the current diff using GitHub Copilot CLI by default.
#   - The first non-flag argument after -ai (if any) is treated as optional
#     extra context to append to the default AI prompt.
#   - The next non-flag argument (if any) is used as a fallback/manual
#     commit message if AI is unavailable or fails.
#   - Without -ai, the first non-flag argument is the commit message,
#     defaulting to "default commit message".
#
# AI integration:
#   Default behaviour (no configuration needed as long as `copilot` is
#   installed and on PATH):
#     - The script builds a prompt like:
#         "examine differences between the last known push to this repository
#          and the current state, write a clean concise one-three line message
#          for this diff"
#       and, if you provided [ai-context] after -ai, appends that text.
#     - It then calls GitHub Copilot CLI non-interactively:
#         copilot -s --allow-all-tools --allow-all-paths -p "$GIT_UPLOAD_AI_PROMPT"
#
#   Advanced: you may optionally override the full AI command via
#   GIT_UPLOAD_AI_CMD for a single shell/session, but this is not required.

set -euo pipefail

use_ai=false
user_msg=""
ai_extra_context=""

DEFAULT_AI_CMD='copilot -s --allow-all-tools --allow-all-paths -p "$GIT_UPLOAD_AI_PROMPT"'

expect_ai_context_next=false

for arg in "$@"; do
	case "$arg" in
		--aiDiffCommitMsg|-ai)
			use_ai=true
			expect_ai_context_next=true
			;;
		--*)
			# Ignore other flags for now
			;;
		*)
			if [ "$expect_ai_context_next" = true ]; then
				# This non-flag arg immediately after -ai/--aiDiffCommitMsg
				# is treated as optional extra AI context.
				ai_extra_context="$arg"
				expect_ai_context_next=false
			elif [ -z "$user_msg" ]; then
				user_msg="$arg"
			fi
			;;
	esac
done

detect_test_cmd() {
	local repo_root="$1"
	if [ -z "${repo_root// /}" ]; then
		repo_root="."
	fi

	# Priority:
	#  1) Explicit env var (caller-controlled)
	#  2) Per-repo git config
	#  3) Repo-local test runner / Makefile
	#  4) Simple heuristics for common stacks
	if [ -n "${GIT_UPLOAD_TEST_CMD-}" ]; then
		printf '%s' "$GIT_UPLOAD_TEST_CMD"
		return 0
	fi

	local cfg_cmd
	cfg_cmd=$(git config --get git-upload.testCmd 2>/dev/null || echo "")
	if [ -n "${cfg_cmd// /}" ]; then
		printf '%s' "$cfg_cmd"
		return 0
	fi

	if [ -x "$repo_root/scripts/test.sh" ]; then
		printf '%s' './scripts/test.sh'
		return 0
	fi

	if { [ -f "$repo_root/Makefile" ] || [ -f "$repo_root/makefile" ]; } && command -v make >/dev/null 2>&1; then
		local mk
		mk=$([ -f "$repo_root/Makefile" ] && echo "$repo_root/Makefile" || echo "$repo_root/makefile")
		if grep -qE '^test:' "$mk" 2>/dev/null; then
			printf '%s' 'make test'
			return 0
		fi
	fi

	if [ -f "$repo_root/package.json" ] && command -v npm >/dev/null 2>&1; then
		# If package.json exists, assume a test script likely exists.
		printf '%s' 'npm test --silent'
		return 0
	fi

	if { [ -f "$repo_root/pyproject.toml" ] || [ -f "$repo_root/pytest.ini" ] || [ -d "$repo_root/tests" ]; } && command -v pytest >/dev/null 2>&1; then
		printf '%s' 'pytest -q'
		return 0
	fi

	if [ -f "$repo_root/go.mod" ] && command -v go >/dev/null 2>&1; then
		printf '%s' 'go test ./...'
		return 0
	fi

	if [ -f "$repo_root/Cargo.toml" ] && command -v cargo >/dev/null 2>&1; then
		printf '%s' 'cargo test -q'
		return 0
	fi

	if [ -f "$repo_root/pom.xml" ] && command -v mvn >/dev/null 2>&1; then
		printf '%s' 'mvn test -q'
		return 0
	fi

	if [ -x "$repo_root/gradlew" ]; then
		printf '%s' './gradlew test -q'
		return 0
	fi
	if { [ -f "$repo_root/build.gradle" ] || [ -f "$repo_root/build.gradle.kts" ]; } && command -v gradle >/dev/null 2>&1; then
		printf '%s' 'gradle test -q'
		return 0
	fi

	return 1
}

summarize_test_output() {
	# Args:
	#  1) test_cmd
	#  2) exit_code
	#  3) path to output file
	local test_cmd="$1"
	local exit_code="$2"
	local output_file="$3"

	local status
	if [ "$exit_code" -eq 0 ]; then
		status='pass'
	else
		status='fail'
	fi

	# If the runner emitted a machine-parseable summary, prefer it.
	# Format:
	#   TEST_SUMMARY: pass 7/7
	#   TEST_SUMMARY: fail 2/7
	#   TEST_FAIL: <name>
	local summary_line
	summary_line=$(grep '^TEST_SUMMARY: ' "$output_file" | tail -n 1 || true)
	if [ -n "${summary_line// /}" ]; then
		local sum_status
		local sum_counts
		sum_status=$(printf '%s\n' "$summary_line" | awk '{print $2}')
		sum_counts=$(printf '%s\n' "$summary_line" | awk '{print $3}')
		if [ -n "${sum_status// /}" ] && [ -n "${sum_counts// /}" ]; then
			local header="Testing: ${sum_status} (${sum_counts})"
			if [ "$sum_status" = "fail" ]; then
				local sum_failures
				sum_failures=$(grep '^TEST_FAIL: ' "$output_file" | sed 's/^TEST_FAIL: //' | head -n 10)
				if [ -n "${sum_failures// /}" ]; then
					printf '%s\n' "$header"
					printf '%s\n' "$sum_failures" | sed 's/^/- /'
					return 0
				fi
			fi
			printf '%s' "$header"
			return 0
		fi
	fi

	local passed=""
	local failed=""
	local total=""
	local count_suffix=""
	local failures=""

	case "$test_cmd" in
		pytest*)
			passed=$(grep -Eo '[0-9]+ passed' "$output_file" | tail -n 1 | awk '{print $1}')
			failed=$(grep -Eo '[0-9]+ failed' "$output_file" | tail -n 1 | awk '{print $1}')
			if [ -n "$passed" ] || [ -n "$failed" ]; then
				local p=${passed:-0}
				local f=${failed:-0}
				total=$((p + f))
				if [ "$total" -gt 0 ]; then
					if [ "$status" = "pass" ]; then
						count_suffix=" ($passed/$total)"
					else
						count_suffix=" ($failed/$total)"
					fi
				fi
			fi
			if [ "$status" = "fail" ]; then
				failures=$(grep '^FAILED ' "$output_file" | sed 's/^FAILED //' | head -n 10)
			fi
			;;
		"npm test"*|"npm test --silent"*)
			# Jest and many JS runners print a "Tests:" summary; best-effort parse.
			# Example: "Tests:       2 failed, 3 passed, 5 total"
			local tests_line
			tests_line=$(grep -E '^Tests:' "$output_file" | tail -n 1 || true)
			if [ -n "$tests_line" ]; then
				failed=$(printf '%s\n' "$tests_line" | grep -Eo '[0-9]+ failed' | awk '{print $1}' | tail -n 1)
				passed=$(printf '%s\n' "$tests_line" | grep -Eo '[0-9]+ passed' | awk '{print $1}' | tail -n 1)
				total=$(printf '%s\n' "$tests_line" | grep -Eo '[0-9]+ total' | awk '{print $1}' | tail -n 1)
				if [ -n "$total" ]; then
					if [ "$status" = "pass" ] && [ -n "$passed" ]; then
						count_suffix=" ($passed/$total)"
					elif [ "$status" = "fail" ] && [ -n "$failed" ]; then
						count_suffix=" ($failed/$total)"
					fi
				fi
			fi
			if [ "$status" = "fail" ]; then
				# Jest prints failing suites as: "FAIL  path/to/test"
				failures=$(grep -E '^FAIL\s+' "$output_file" | sed -E 's/^FAIL\s+//' | head -n 10)
			fi
			;;
		*)
			# Unknown runner; keep it simple.
			;;
	esac

	local header="Testing: ${status}${count_suffix}"
	if [ "$status" = "fail" ] && [ -n "${failures// /}" ]; then
		printf '%s\n' "$header"
		printf '%s\n' "$failures" | sed 's/^/- /'
		return 0
	fi

	printf '%s' "$header"
}

compute_testing_status() {
	local repo_root
	repo_root=$(git rev-parse --show-toplevel 2>/dev/null || echo "")
	if [ -z "${repo_root// /}" ]; then
		printf '%s' 'Testing: not configured'
		return 0
	fi

	local test_cmd
	if ! test_cmd=$(detect_test_cmd "$repo_root"); then
		printf '%s' 'Testing: not configured'
		return 0
	fi

	echo "[git-upload] Running test command (from repo root): $test_cmd" >&2

	local tmp
	tmp=$(mktemp -t git-upload-tests.XXXXXX)
	local exit_code=0

	# Don't let test failures abort the script under set -e.
	if (cd "$repo_root" && eval "$test_cmd") >"$tmp" 2>&1; then
		exit_code=0
	else
		exit_code=$?
	fi

	local summary
	summary=$(summarize_test_output "$test_cmd" "$exit_code" "$tmp")
	rm -f "$tmp" >/dev/null 2>&1 || true

	printf '%s' "$summary"
}

generate_ai_message() {
	local ai_cmd

	if [ -n "${GIT_UPLOAD_AI_CMD-}" ]; then
		ai_cmd="$GIT_UPLOAD_AI_CMD"
	else
		ai_cmd="$DEFAULT_AI_CMD"
	fi

	local ai_binary
	ai_binary=${ai_cmd%% *}
	if ! command -v "$ai_binary" >/dev/null 2>&1; then
		echo "[git-upload] AI command '$ai_binary' not found. " \
			"Install GitHub Copilot CLI (e.g. 'brew install copilot-cli' on macOS) " \
			"and ensure it is on your PATH." >&2
		return 1
	fi

	local testing_status
	testing_status=$(compute_testing_status)

	local default_prompt="You are generating a git commit message for the CURRENT STAGED CHANGES.

Your job:
- Determine what changed between the last commit (HEAD) and the current staged snapshot (index). If there is no HEAD yet (initial commit), base it on the staged snapshot.
- Write a reasonable-length but very informative commit message that explains what changed and why, so a teammate can understand it weeks later.

Content requirements:
- Base everything on the staged diff (index) vs HEAD; do not invent changes.
- If multiple areas changed, group them; prioritize user-visible behavior changes and operational impact.
- Call out CLI/API behavior changes, default behavior changes, and backwards compatibility.
- If applicable, include migration steps; otherwise explicitly say: Breaking changes: none
- Include a short risk assessment; if nothing stands out, say: Risk: low
- For Testing, use the provided testing status EXACTLY (verbatim). Do not guess.

Style requirements:
- Subject line: imperative mood; concise and specific; aim for <= 72 characters when feasible.
- Body: detailed but not padded; prefer bullets.
- Do NOT mention checking status, diffs, tools, agents, prompts, or instructions.

Output protocol (IMPORTANT):
- Output ONLY the commit message between these exact markers, with no other text:
COMMIT_BEGIN
<subject line>

<body, multiple lines allowed>
COMMIT_END

Suggested body structure (adapt as needed):
Summary:
- <bullet per major change>
Why:
- <motivation/problem addressed>
Breaking changes: <none|describe>
Risk: <low|medium|high> (<short rationale>)
Testing: <use the provided testing status verbatim>
"
	local effective_prompt

	effective_prompt="$default_prompt

Authoritative testing status (use verbatim in the commit message):
$testing_status"
	if [ -n "$ai_extra_context" ]; then
		effective_prompt="$effective_prompt

Additional context from user: $ai_extra_context"
	fi

	echo "[git-upload] Generating AI commit message via Copilot…" >&2

	# Call Copilot CLI (or overridden AI command) with the constructed prompt.
	# Capture full output so we can extract the commit message.
	local ai_output
	if ! ai_output=$(GIT_UPLOAD_AI_PROMPT="$effective_prompt" eval "$ai_cmd" 2>/dev/null); then
		echo "[git-upload] AI command '$ai_cmd' failed. " \
			"Make sure GitHub Copilot CLI is installed and you have run 'copilot' " \
			"at least once to authenticate." >&2
		return 1
	fi

	# Prefer COMMIT_BEGIN/COMMIT_END block; fall back to legacy single-line COMMIT:.
	local commit_block
	commit_block=$(printf '%s\n' "$ai_output" | awk '
		$0 == "COMMIT_BEGIN" { inside=1; next }
		$0 == "COMMIT_END" { inside=0 }
		inside { print }
	')

	if [ -n "${commit_block// /}" ]; then
		# Trim trailing blank lines.
		commit_block=$(printf '%s\n' "$commit_block" | awk '{ lines[NR]=$0 } $0 !~ /^[[:space:]]*$/ { last=NR } END { for (i=1; i<=last; i++) print lines[i] }')
		# Trim leading blank lines.
		commit_block=$(printf '%s\n' "$commit_block" | awk 'BEGIN{found=0} { if (!found && $0 ~ /^[[:space:]]*$/) next; found=1; print }')
		if [ -n "${commit_block// /}" ]; then
			printf '%s' "$commit_block"
			return 0
		fi
	fi

	local commit_line
	commit_line=$(printf '%s\n' "$ai_output" | grep '^COMMIT: ' | tail -n 1 | sed 's/^COMMIT: //')

	if [ -z "${commit_line// /}" ]; then
		echo "[git-upload] AI did not produce a COMMIT_BEGIN/COMMIT_END block (or legacy COMMIT: line); skipping AI" >&2
		return 1
	fi

	printf '%s' "$commit_line"
}

main() {
	# Determine current branch and ensure we're not in detached HEAD.
	# NOTE: `git rev-parse --abbrev-ref HEAD` can yield surprising output in
	# brand-new repos (unborn branch / no commits yet). `git symbolic-ref` is
	# the reliable way to identify the branch HEAD points to.
	current_branch=$(git symbolic-ref -q --short HEAD 2>/dev/null || echo "")
	if [ -z "$current_branch" ]; then
		# HEAD is detached (or otherwise not a symbolic ref).
		head_commit=$(git rev-parse -q --verify HEAD 2>/dev/null || echo "")
		if [ -z "$head_commit" ]; then
			echo "[git-upload] HEAD is not on a branch (and there are no commits yet)." >&2
			echo "[git-upload] Fix: create/switch to a branch first (for example: 'git switch -c main')." >&2
			exit 1
		fi

		# If the detached commit is already contained by exactly one local branch,
		# we can safely switch to it without losing work.
		containing_branches=$(git branch --contains "$head_commit" --format='%(refname:short)' 2>/dev/null || echo "")
		containing_count=$(printf '%s\n' "$containing_branches" | sed '/^$/d' | wc -l | tr -d ' ')

		if [ "$containing_count" = "1" ]; then
			current_branch=$(printf '%s\n' "$containing_branches" | sed -n '1p')
			echo "[git-upload] Detached HEAD is contained by '$current_branch'; switching to that branch…" >&2
			git switch "$current_branch" >/dev/null 2>&1 || {
				echo "[git-upload] Failed to switch to '$current_branch'." >&2
				exit 1
			}
		else
			echo "[git-upload] You are in a detached HEAD state. Checkout or create a branch before running git-upload." >&2
			echo "[git-upload] Fix (create a branch at the current commit): git switch -c <branch-name>" >&2
			exit 1
		fi
	fi

	# If this branch has an upstream, first make sure we're not behind it.
	# If we are, attempt a rebase so pushes will be fast-forward and won't
	# immediately fail due to "non-fast-forward" errors.
	if upstream_ref=$(git rev-parse --abbrev-ref --symbolic-full-name "@{u}" 2>/dev/null); then
		# Make sure we have the latest refs
		git fetch >/dev/null 2>&1 || true

		ahead_behind=$(git rev-list --left-right --count "$upstream_ref"...HEAD 2>/dev/null || echo "")
		behind_count=$(print -- "$ahead_behind" | awk '{print $1}')

		if [ -n "$behind_count" ] && [ "$behind_count" -gt 0 ]; then
			echo "[git-upload] Branch '$current_branch' is $behind_count commit(s) behind its upstream. Rebasing..." >&2
			if ! git pull --rebase --autostash >/dev/null 2>&1; then
				GIT_DIR=$(git rev-parse --git-dir 2>/dev/null || echo .git)
				if [ -d "$GIT_DIR/rebase-merge" ] || [ -d "$GIT_DIR/rebase-apply" ] || [ -f "$GIT_DIR/MERGE_HEAD" ]; then
					echo "[git-upload] git pull --rebase --autostash stopped due to conflicts." >&2
					echo "[git-upload] Run 'git resolve' for a safe backup and conflict-resolution guidance, resolve conflicts, then rerun git-upload." >&2
				else
					echo "[git-upload] git pull --rebase --autostash failed for this branch (for example, due to local changes or a hook/network error)." >&2
					echo "[git-upload] Run 'git resolve' for a safe backup and guidance on cleaning up your working tree, then rerun git-upload." >&2
				fi
				exit 1
			fi
		fi

		# After ensuring we're up to date, do a dry-run push to catch
		# permission/branch-protection issues before burning AI tokens.
		if ! git push --dry-run >/dev/null 2>&1; then
			echo "[git-upload] Unable to push to the upstream for '$current_branch'." >&2
			echo "[git-upload] This branch may be protected or you may not have permission to push directly." >&2
			echo "[git-upload] Push via a pull request or use a different branch before running git-upload." >&2
			exit 1
		fi
	fi

	git add .

	commit_msg="${user_msg:-default commit message}"

	if [ "$use_ai" = true ]; then
		if ai_msg=$(generate_ai_message); then
			# Prefer AI message; fall back to user_msg if AI returns empty
			if [ -n "${ai_msg// /}" ]; then
				commit_msg="$ai_msg"
			fi
		else
			# AI failed (e.g., Copilot not authenticated or not available)
			if [ -z "$user_msg" ]; then
				# No manual fallback message was provided; abort commit
				echo "[git-upload] AI commit requested but unavailable and no fallback commit message provided. Aborting commit." >&2
				exit 1
			fi
		fi
	fi

	echo "[git-upload] Using commit message: $commit_msg" >&2

	git commit -m "$commit_msg"

	# Push to the current branch's upstream if configured; otherwise
	# create/set upstream on origin for the current branch.
	if git rev-parse --abbrev-ref --symbolic-full-name "@{u}" >/dev/null 2>&1; then
		git push
	else
		git push -u origin "$current_branch"
	fi
}

main "$@"